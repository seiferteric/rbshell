#!/usr/bin/ruby

require 'ripper'
require 'reline'
require 'irb/ruby-lex'

require_relative 'lib/rbshell.rb'
# require 'readline'
require 'socket'
require 'etc'



shell = RbShell.new(File.join(__dir__, File.basename(__FILE__)))

#Should somehow use the completion profile from irb... that would be nice
# Readline.completion_proc = proc {|s| RbShell::Command.instance_methods(false).filter {|m| m.start_with? s}}

# while buf = Readline.readline(Etc.getlogin + "@" + Socket.gethostname + ":" + Dir.pwd + "$ ", true)
#   begin
#     if !buf.empty?
#       r = shell.run(buf)
#       if r != nil
#         #Explicit call to .to_s for array...
#         puts (r.to_s)
#       end
#     end
#   rescue Exception => e
#     p "invalid command: " + e.to_s
#   end

# end

$nprompt = ">"
$cprompt = Etc.getlogin + "@" + Socket.gethostname + ":" + Dir.pwd + "$ "
$prompt = $cprompt

$prompt_proc = Proc.new {|buf| [$prompt]}


Reline.prompt_proc = $prompt_proc

class TerminationChecker < RubyLex
  def terminated?(code)
    code.gsub!(/\n*$/, '').concat("\n")
    @tokens = Ripper.lex(code)
    continue = process_continue
    code_block_open = check_code_block(code)
    indent = process_nesting_level
    ltype = process_literal_type
    if code_block_open or ltype or continue or indent > 0
      $prompt = $nprompt
      false
    else
      $prompt = $cprompt
      true
    end
  end
end

checker = TerminationChecker.new
while code = Reline.readmultiline(nil, true) { |code| checker.terminated?(code) }
  case code.chomp
  when ''
    # NOOP
  else
    begin
      r = shell.run(code)
      if r != nil
        #Explicit call to .to_s for array...
        puts (r.to_s)
      end
    rescue ScriptError, StandardError => e
      puts "Traceback (most recent call last):"
      e.backtrace.reverse_each do |f|
        puts "        #{f}"
      end
      puts e.message
    end
  end

end